<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>壁紙を選択</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <link href="light.css" rel="stylesheet">
    <script type="importmap">
    {
      "imports": {
        "@material/web/": "https://esm.run/@material/web/"
      }
    }
  </script>
  <script type="module">
    import '@material/web/all.js';
    import {styles as typescaleStyles} from '@material/web/typography/md-typescale-styles.js';

    document.adoptedStyleSheets.push(typescaleStyles.styleSheet);
  </script>
    <style>
        :root {
            
            --md-sys-elevation-1: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);

            /* Typography */
            font-family:  'Roboto', 'Noto Sans JP', sans-serif;
            font-weight: 400;

            --header-height: 56px;
            --md-ripple-hover-color:#0000;
            --md-ripple-pressed-color:var(--md-sys-color-surface-container-low);
            --md-ripple-pressed-opacity:0.5;

            --slide-offset: 30vw;
            --genre-card-image-height: 200px;
        }
        ::-webkit-scrollbar {
            display: none;
        }
        body {
            background: var(--md-sys-color-surface-container-low);
            color: var(--md-sys-color-on-surface);
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        .view-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;

            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            transition: all 0.6s cubic-bezier(.72,0,0,1);

            opacity: 0;
            pointer-events: none;
            z-index: 10;
            scale:1;
        }

        .view-wrapper.offscreen-left {
            left: -30vw;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
            scale:0.95;
        }

        .view-wrapper.offscreen-right {
            left: 30vw;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
            scale:1.05;
        }

        .view-wrapper.active {
            left: 0;
            opacity: 1;
            pointer-events: auto;
            z-index: 30;
        }

        #loading-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--md-sys-color-surface-container-low);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            scale:1;
            opacity:1;
            text-align:center;
        }

        #loading-container.offscreen-left {
            left: -30vw;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
            scale:0.9;
        }


        #loading-content {
            width: 90%;
            max-width: 600px;
            margin: auto;
        }

        header {
            background-color: var(--md-sys-color-surface-container-low);
            color: var(--md-sys-color-on-surface);
            padding: 40px 32px;
            box-shadow: none;
            z-index: 100;
            display: flex;
            align-items: center;
            box-sizing: border-box;
            position: static;
            width: 100%;
            --md-ripple-pressed-color:var(--md-sys-color-on-surface);
            --md-ripple-pressed-opacity:0.2;
        }

        header h1 {
            font-size: 2rem;
            font-weight: 400;
            margin: 0;
            line-height: 1;
        }

        #genre-content, #gallery-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0 20px 20px 20px;
            background: var(--md-sys-color-surface-container-low);
        }

        #loading-bar-container {
            width: 100%;
            background-color: var(--md-sys-color-surface-container);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        #loading-bar {
            height: 8px;
            width: 0%;
            background-color: var(--md-sys-color-primary);
            color: transparent;
            transition: width 0.3s;
            border-radius: 8px;
        }

        #loading-text {
            font-size: 16px;
            color: var(--md-sys-color-on-surface);
            margin: 0;
        }

        #genre-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .genre-card {
            background: none;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
            position:relative;
            border-radius:32px;
        }

        .genre-card:hover {
            box-shadow: none;
            transform: none;
        }

        .genre-image-container {
            width: 100%;
            height: var(--genre-card-image-height);
            display: block;
            background-image:unset;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 100px;
            transition:all 0.6s cubic-bezier(.34,.24,0,1), background-image 0.3s ease; /* ホバー時のトランジション */
            background-color: var(--md-sys-color-surface-container-high);
            corner-shape:superellipse(1.1);
        }

        .genre-image-container:hover {
            border-radius: 50px;
            corner-shape:superellipse(1.5);
        }

        .genre-card-content {
            padding: 16px 0;
            text-align: center;
        }

        .genre-card-content h3 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 400;
            color: var(--md-sys-color-on-surface);
        }

        /* --- Gallery View: Image Grid (修正) --- */
        #back-button {
            background: var(--md-sys-color-surface-container-highest);
            margin-right: 12px;
            padding: 16px;
            border: none;
            cursor: pointer;
            border-radius: 50%;
            color: var(--md-sys-color-on-surface);
            position:relative;
        }
        #image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
            padding-top: 20px;
        }

        #image-gallery > div {
            corner-shape:superellipse(1.6);
            border-radius: 64px;
            background: var(--md-sys-color-surface-container);
            overflow: hidden;
            box-shadow: var(--md-sys-elevation-1);
        }
        .gallery-image-wrapper {
            width: 100%;
            aspect-ratio: 16/9;
            cursor: pointer;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position:relative;
            background-color: var(--md-sys-color-surface-container-high);
            transition: background-image 0.3s ease; /* ホバー時のトランジション */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>

    <div class="view-wrapper" id="loading-container">
        <div id="loading-content">
            <div id="loading-bar-container">
                <div id="loading-bar">0%</div>
            </div>
            <p id="loading-text">スクリプトとライブラリを読み込み中...</p>
        </div>
    </div>

    <div id="genre-view" class="view-wrapper offscreen-right">
        <header>
            <h1 id="app-title">壁紙を選択</h1>
        </header>
        <div id="genre-content">
            <div id="genre-list">
            </div>
        </div>
    </div>

    <div id="gallery-view" class="view-wrapper offscreen-right">
        <header>
            <span id="back-button" class="material-symbols-outlined" style="display:inline-flex;"><md-ripple></md-ripple>arrow_back</span>
            <h1 id="gallery-title-header"></h1>
        </header>
        <div id="gallery-content">
            <div id="image-gallery">
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
    const ZIP_URL = 'https://search3958.github.io/newtab/bgimg/zip/main.zip';
    const LOCAL_STORAGE_KEY = 'wallpaperData';

    const loadingContainer = document.getElementById('loading-container');
    const genreView = document.getElementById('genre-view');
    const galleryView = document.getElementById('gallery-view');
    const genreList = document.getElementById('genre-list');
    const imageGallery = document.getElementById('image-gallery');
    const galleryTitleHeader = document.getElementById('gallery-title-header');
    const backButton = document.getElementById('back-button');
    const appTitle = document.getElementById('app-title');

    let allWallpaperData = null;
    let currentViewElement = null;
    let isAnimating = false;
    const TRANSITION_DURATION_MS = 600;

    // 変更: ホバー用の画像キャッシュを廃止し、データを直接オブジェクトに格納します
    // const hoverImageCache = new Map(); 

    function updateProgress(percent, text) {
        const loadingBar = document.getElementById('loading-bar');
        const loadingText = document.getElementById('loading-text');
        const safePercent = Math.min(100, percent);
        loadingBar.style.width = safePercent + '%';
        loadingBar.textContent = `${Math.round(safePercent)}%`;
        loadingText.textContent = text;
    }

    function processZipFile() {
        return new Promise((resolve, reject) => {
            updateProgress(5, '準備中');
            const xhr = new XMLHttpRequest();
            xhr.open('GET', ZIP_URL, true);
            xhr.responseType = 'arraybuffer';
            xhr.onprogress = function(event) {
                if (event.lengthComputable) {
                    let percent = (event.loaded / event.total) * 90;
                    updateProgress(percent, `${(event.loaded/1024/1024).toFixed(2)} MB ダウンロード済み`);
                }
            };
            xhr.onload = function() {
                if (xhr.status === 200) {
                    updateProgress(90, '解凍中');
                    const zipFile = xhr.response;
                    const structuredData = {};
                    // 変更: ホバー画像検出用の一時マップ (キー: fullPath, 値: Promise<Blob>)
                    const darkImageMap = new Map(); 

                    JSZip.loadAsync(zipFile).then(function(zip) {
                        const imagePromises = [];

                        // Step 1: 全ファイルを走査し、通常画像とホバー画像を分類する
                        zip.forEach(function(relativePath, zipEntry) {
                            if (zipEntry.dir) return;

                            const fileName = relativePath.toLowerCase();
                            const parts = relativePath.split('/');
                            const baseFileName = parts[parts.length - 1];

                            if (
                                (fileName.endsWith('.png') || fileName.endsWith('.webp')) &&
                                !baseFileName.startsWith('.')
                            ) {
                                const genre = parts.length > 1 ? parts[parts.length - 2] : 'その他';
                                
                                if (!structuredData[genre]) { structuredData[genre] = []; }

                                if (baseFileName.includes('_dark')) {
                                    // ★ _dark ファイルは一時マップに格納 (通常画像にはしない)
                                    darkImageMap.set(relativePath, zipEntry.async('blob'));
                                } else {
                                    // 通常画像（ライトバージョン）の処理
                                    const imageObject = { 
                                        name: baseFileName, 
                                        url: null, 
                                        size: 0,
                                        hoverUrl: null // ★ ここにホバーURLを格納する
                                    };
                                    structuredData[genre].push(imageObject);

                                    const baseNameWithoutExt = imageObject.name.replace(/\.[^/.]+$/, "");
                                    const extension = fileName.substring(fileName.lastIndexOf('.'));
                                    const expectedHoverName = `${baseNameWithoutExt}_dark${extension}`;
                                    
                                    // 同じディレクトリ内のホバー画像パスを計算
                                    const expectedHoverPath = relativePath.replace(imageObject.name, expectedHoverName); 

                                    // URL生成のPromiseを準備
                                    const filePromise = zipEntry.async('blob').then(function(blob) {
                                        imageObject.url = URL.createObjectURL(blob);
                                        imageObject.size = blob.size;

                                        // ★ Step 2: 同じディレクトリ内に対応する _dark ファイルがあるか確認
                                        const darkEntry = zip.file(expectedHoverPath);
                                        if (darkEntry) {
                                            // _dark ファイルを見つけたら、その URL を生成して hoverUrl に格納する
                                            return darkEntry.async('blob').then(darkBlob => {
                                                imageObject.hoverUrl = URL.createObjectURL(darkBlob);
                                            });
                                        }
                                    });
                                    imagePromises.push(filePromise);
                                }
                            }
                        });

                        // darkImageMapのファイル処理は不要になりましたが、
                        // promiseが全て完了するのを待ちます。
                        return Promise.all(imagePromises); 
                    }).then(() => {
                        updateProgress(100, '完了');
                        resolve(structuredData);
                    }).catch(error => {
                        updateProgress(100, 'エラーが発生しました。');
                        console.error('ZIPファイルの処理中にエラー:', error);
                        reject('ZIP_PROCESSING_ERROR');
                    });
                } else {
                    updateProgress(100, `エラーが発生しました: HTTPステータス ${xhr.status}`);
                    console.error('ダウンロード中にHTTPエラー:', xhr.status, xhr.statusText);
                    reject('HTTP_ERROR');
                }
            };
            xhr.onerror = function() {
                updateProgress(100, 'ネットワークエラーが発生しました。');
                console.error('ネットワークエラー');
                reject('NETWORK_ERROR');
            };
            xhr.send();
        });
    }

    async function loadWallpaperData() {
        const cachedData = localStorage.getItem(LOCAL_STORAGE_KEY);
        // キャッシュチェックは残しますが、ZIPファイル処理が毎回行われる仕様なので、
        // 開発/デバッグ中はキャッシュを無効にしても良いかもしれません。
        if (cachedData) {
            try {
                updateProgress(100, 'キャッシュからデータをロード中...');
                allWallpaperData = JSON.parse(cachedData);
            } catch (e) {
                localStorage.removeItem(LOCAL_STORAGE_KEY);
            }
        }
        try {
            allWallpaperData = await processZipFile();
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(allWallpaperData));
            return true;
        } catch (e) {
            console.error('データのロードに失敗しました。', e);
            return false;
        }
    }


    function switchView(nextViewElement, isBackNavigation = false) {
        if (isAnimating || nextViewElement === currentViewElement) return;

        isAnimating = true;
        const prevViewElement = currentViewElement;

        let exitClass, enterClass, postExitClass;

        if (isBackNavigation) {
            enterClass = 'offscreen-left';
            exitClass = 'offscreen-right';
            postExitClass = 'offscreen-right';
        } else {
            enterClass = 'offscreen-right';
            exitClass = 'offscreen-left';
            postExitClass = 'offscreen-left';
        }

        nextViewElement.classList.remove('active', 'offscreen-left', 'offscreen-right');
        nextViewElement.classList.add(enterClass);

        nextViewElement.style.zIndex = 40;
        if (prevViewElement) {
             prevViewElement.style.zIndex = 35;
        }

        nextViewElement.offsetWidth;

        window.requestAnimationFrame(() => {
            nextViewElement.classList.remove(enterClass);
            nextViewElement.classList.add('active');

            if (prevViewElement) {
                prevViewElement.classList.remove('active');
                prevViewElement.classList.remove('offscreen-left', 'offscreen-right');
                prevViewElement.classList.add(exitClass);
            }

            nextViewElement.addEventListener('transitionend', function handler(event) {
                if (event.propertyName !== 'left') return;

                nextViewElement.removeEventListener('transitionend', handler);

                isAnimating = false;
                nextViewElement.style.zIndex = 30;

                if (prevViewElement) {
                    prevViewElement.classList.remove(exitClass);
                    prevViewElement.classList.add(postExitClass);
                    prevViewElement.style.zIndex = 10;
                }
            });
        });

        currentViewElement = nextViewElement;
    }

    // ホバーイベントを設定する関数
    function setupHoverEvent(element, originalUrl, hoverUrl) {
        // hoverUrlがnullやundefinedの場合はホバーイベントを設定しない
        if (!hoverUrl) return; 

        element.addEventListener('mouseenter', () => {
            element.style.backgroundImage = `url('${hoverUrl}')`;
        });

        element.addEventListener('mouseleave', () => {
            element.style.backgroundImage = `url('${originalUrl}')`;
        });
    }

    function renderGenreView(isInitialLoad = false, isBack = false) {
        genreList.innerHTML = '';

        if (!allWallpaperData) return;

        const sortedGenres = Object.keys(allWallpaperData).sort();

        sortedGenres.forEach(genre => {
            const images = allWallpaperData[genre];
            if (images.length === 0) return;

            const coverImage = images[0];

            const card = document.createElement('div');
            card.className = 'genre-card';
            card.dataset.genre = genre;
            card.innerHTML = `
                <div class="genre-image-container" style="background-image: url('${coverImage.url}')" 
                    alt="${genre}のカバー画像"></div>
                <div class="genre-card-content">
                    <h3>${genre}</h3>
                </div><md-ripple></md-ripple>
            `;

            // ジャンルビューではホバーイベントを設定しない (要件通り)
            // const imageContainer = card.querySelector('.genre-image-container'); 

            card.addEventListener('click', () => {
                showGalleryView(genre);
            });

            genreList.appendChild(card);
        });

        appTitle.textContent = '壁紙を選択';

        if (isInitialLoad) {
            loadingContainer.classList.add('offscreen-left');
            genreView.classList.remove('offscreen-left');
            genreView.classList.add('offscreen-right');

            setTimeout(() => {
                genreView.classList.remove('offscreen-right');
                genreView.classList.add('active');
                currentViewElement = genreView;
            }, 10);

        } else {
            switchView(genreView, isBack);
        }
    }

    function showGalleryView(genre) {
        imageGallery.innerHTML = '';

        const images = allWallpaperData[genre];
        galleryTitleHeader.textContent = `${genre}`;

        images.forEach(image => {
            const div = document.createElement('div');
            div.innerHTML = `
                <div class="gallery-image-wrapper"
                    style="background-image: url('${image.url}')"
                    title="${image.name}"><md-ripple></md-ripple></div>
            `;

            const imageWrapper = div.querySelector('.gallery-image-wrapper');
            // 変更: image.hoverUrl を直接使用
            setupHoverEvent(imageWrapper, image.url, image.hoverUrl);

            imageGallery.appendChild(div);
        });
        switchView(galleryView, false);
    }

    loadWallpaperData().then(success => {
        if (success) {
            renderGenreView(true);
        } else {
            loadingContainer.style.display = 'flex';
            const loadingText = document.getElementById('loading-text');
            loadingText.style.color = 'red';
            loadingText.textContent = 'データのロード中に致命的なエラーが発生しました。';
        }
    });

    backButton.addEventListener('click', () => {
        if (currentViewElement === galleryView) {
            renderGenreView(false, true);
        }
    });

});
    </script>
</body>
</html>